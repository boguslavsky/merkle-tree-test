# merkle-tree-test

Предположим, есть некоторые данные, которые хранятся упорядочено в списке.

Merkle дерево — это бинарное дерево, с помощью которого можно проверить целостность и порядок этих данных в списке. Причем проверять на целостность можно как все элементы списка, так и некоторый диапазон элементов.

Суть проверки состоит в том, чтобы "свернуть" все дерево до корневого хеша и удостоверится, что он совпадает с ожидаемым, а количество и порядок элементов в дереве строго соответствует ожидаемому.

##### Проверка полного сбалансированного дерева:

```
Level         Tree root

  0              14
              /       \
  1          12       13
           /   \    /   \
  2       8    9   10   11
         /\   /\   /\   /\
  3     0 1  2 3  4 5  6 7 
```

В листьях этого дерева (от `0` до `7` включительно) хранятся проверяемые элементы списка.

Для начала необходимо посчитать хеши элементов `0` и `1`. Зная их, можно получить значение узла `8` с помощью формулы: 

```
node_8 = hash(hash(0) + hash(1))
```

Операция суммирования в данной формуле применятся над хешами, представленными в виде массивов беззнаковых 8-битных целых чисел (Uint8Array) и представляет собою конкатенацию этих массивов.

Посчитав значение узла `9` аналогичным образом, можно посчитать значение узла `12`:

```
node_12 = hash(node_8 + node_9)
```

По аналогии мы получаем значение корневого узла `14` и сравниваем его с ожидаемым.

##### Проверка несбалансированного дерева:

В случае со несбалансированным деревом в одной из ветвей с листьями будет элемент без пары. Его хеш следует переносить в родительский узел без изменений.

##### Проверка неполного дерева:

В случае, когда в дереве находятся не все элементы списка с данными, а лишь некоторый диапазон — в правой части дерева будет один или несколько хешей, каждый из которых представляет собою хеш, посчитанный от отсутствующей части дерева. В примерах данных ниже для удобства данный хеш записан в виде шестнадцатеричных строк. Однако для формул, представленных выше, его необходимо будет конвертировать в массивы типа Uint8Array.

# Задача:

1) Написать функцию, которая будет проверять целостность данных в Merkle дереве.
2) Покрыть функцию тестами.
3) Сделать так, чтобы функцию можно было использовать как в браузере, так и в Node.js.

Элементы списка представлены в виде массивов беззнаковых 8-битных целых чисел (Uint8Array). Для подсчета хеша такого элемента необходимо использовать криптографическую функцию SHA256 (например, из библиотеки [sha.js](https://www.npmjs.com/package/sha.js)), которая даст на выходе массив типа Uint8Array длинною 32 байта.

##### Входящие параметры:

* `rootHash` — hash корневого элемента;
* `total` — общее количество элементов в списке;
* `range` — диапазон элементов списка, представленный в дереве: `[a, b)` от `a` включительно до `b` не включительно;
* `tree` — Merkle дерево.

Если дерево корректно — на выходе ожидается `true`, в остальных случаях `false`.

##### Примеры корректных входящих данных:

- [Сбалансированное дерево](data/fully-balanced.json);
- [Диапазон элементов](data/range.json);
- [Единственный элемент](data/single-node.json).
